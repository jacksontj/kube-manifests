{
   "apiVersion": "v1",
   "data": {
      "prometheus.yml": "{\"global\": {\"external_labels\": {\"cluster\": \"one.k8s.dev.bitnami.net\"}, \"scrape_interval\": \"1m\", \"scrape_timeout\": \"30s\"}, \"rule_files\": [\"/etc/prometheus-config/*.rules\"], \"scrape_configs\": [{\"ec2_sd_configs\": [{\"region\": \"us-east-1\"}], \"job_name\": \"ec2_servers\", \"relabel_configs\": [{\"action\": \"labelmap\", \"regex\": \"__meta_ec2_tag_(.+)\"}, {\"action\": \"keep\", \"regex\": \"full|whitebox\", \"source_labels\": [\"__meta_ec2_tag_monitoring_type\"]}, {\"replacement\": \"$1\", \"source_labels\": [\"__meta_ec2_tag_monitoring_vhost\"], \"target_label\": \"__address__\"}], \"scheme\": \"https\", \"tls_config\": {\"insecure_skip_verify\": true}}, {\"ec2_sd_configs\": [{\"region\": \"us-east-1\"}], \"job_name\": \"ec2_servers_blackbox\", \"metrics_path\": \"/probe\", \"params\": {\"module\": [\"http_2xx\"]}, \"relabel_configs\": [{\"action\": \"labelmap\", \"regex\": \"__meta_ec2_tag_(.+)\"}, {\"action\": \"keep\", \"regex\": \"true\", \"source_labels\": [\"__meta_ec2_tag_probe\"]}, {\"regex\": \"(.*)\", \"replacement\": \"$1\", \"source_labels\": [\"__meta_ec2_tag_probe_target\"], \"target_label\": \"__param_target\"}, {\"source_labels\": [\"__meta_ec2_tag_probe_target\"], \"target_label\": \"vhost\"}, {\"replacement\": \"blackbox:9115\", \"target_label\": \"__address__\"}]}, {\"bearer_token_file\": \"/var/run/secrets/kubernetes.io/serviceaccount/token\", \"job_name\": \"kubernetes_apiservers\", \"kubernetes_sd_configs\": [{\"role\": \"endpoints\"}], \"relabel_configs\": [{\"action\": \"keep\", \"regex\": \"default;kubernetes;https\", \"source_labels\": [\"__meta_kubernetes_namespace\", \"__meta_kubernetes_service_name\", \"__meta_kubernetes_endpoint_port_name\"]}], \"scheme\": \"https\", \"tls_config\": {\"ca_file\": \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\", \"insecure_skip_verify\": true}}, {\"bearer_token_file\": \"/var/run/secrets/kubernetes.io/serviceaccount/token\", \"job_name\": \"kubernetes_cadvisor\", \"kubernetes_sd_configs\": [{\"role\": \"node\"}], \"relabel_configs\": [{\"action\": \"labelmap\", \"regex\": \"__meta_kubernetes_node_label_(.+)\"}, {\"replacement\": \"kubernetes.default.svc.cluster.local:443\", \"target_label\": \"__address__\"}, {\"replacement\": \"https\", \"target_label\": \"__scheme__\"}, {\"regex\": \"(.+)\", \"replacement\": \"/api/v1/nodes/${1}/proxy/metrics/cadvisor\", \"source_labels\": [\"__meta_kubernetes_node_name\"], \"target_label\": \"__metrics_path__\"}], \"scheme\": \"https\", \"tls_config\": {\"ca_file\": \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\", \"insecure_skip_verify\": true}}, {\"bearer_token_file\": \"/var/run/secrets/kubernetes.io/serviceaccount/token\", \"job_name\": \"kubernetes_nodes\", \"kubernetes_sd_configs\": [{\"role\": \"node\"}], \"relabel_configs\": [{\"action\": \"labelmap\", \"regex\": \"__meta_kubernetes_node_label_(.+)\"}, {\"replacement\": \"kubernetes.default.svc.cluster.local:443\", \"target_label\": \"__address__\"}, {\"replacement\": \"https\", \"target_label\": \"__scheme__\"}, {\"regex\": \"(.+)\", \"replacement\": \"/api/v1/nodes/${1}/proxy/metrics\", \"source_labels\": [\"__meta_kubernetes_node_name\"], \"target_label\": \"__metrics_path__\"}], \"scheme\": \"https\", \"tls_config\": {\"ca_file\": \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\", \"insecure_skip_verify\": true}}, {\"job_name\": \"kubernetes_pods\", \"kubernetes_sd_configs\": [{\"role\": \"pod\"}], \"relabel_configs\": [{\"action\": \"keep\", \"regex\": true, \"source_labels\": [\"__meta_kubernetes_pod_annotation_prometheus_io_scrape\"]}, {\"action\": \"replace\", \"regex\": \"(.+)\", \"source_labels\": [\"__meta_kubernetes_pod_annotation_prometheus_io_path\"], \"target_label\": \"__metrics_path__\"}, {\"action\": \"replace\", \"regex\": \"(.+):(?:\\\\d+);(\\\\d+)\", \"replacement\": \"${1}:${2}\", \"source_labels\": [\"__address__\", \"__meta_kubernetes_pod_annotation_prometheus_io_port\"], \"target_label\": \"__address__\"}, {\"action\": \"labelmap\", \"regex\": \"__meta_kubernetes_pod_label_(.+)\"}, {\"action\": \"replace\", \"source_labels\": [\"__meta_kubernetes_namespace\"], \"target_label\": \"kubernetes_namespace\"}, {\"action\": \"replace\", \"source_labels\": [\"__meta_kubernetes_pod_name\"], \"target_label\": \"kubernetes_pod_name\"}]}, {\"job_name\": \"kubernetes_service_endpoints\", \"kubernetes_sd_configs\": [{\"role\": \"endpoints\"}], \"relabel_configs\": [{\"action\": \"keep\", \"regex\": true, \"source_labels\": [\"__meta_kubernetes_service_annotation_prometheus_io_scrape\"]}, {\"action\": \"replace\", \"regex\": \"(https?)\", \"source_labels\": [\"__meta_kubernetes_service_annotation_prometheus_io_scheme\"], \"target_label\": \"__scheme__\"}, {\"action\": \"replace\", \"regex\": \"(.+)\", \"source_labels\": [\"__meta_kubernetes_service_annotation_prometheus_io_path\"], \"target_label\": \"__metrics_path__\"}, {\"action\": \"replace\", \"regex\": \"(.+)(?::\\\\d+);(\\\\d+)\", \"replacement\": \"$1:$2\", \"source_labels\": [\"__address__\", \"__meta_kubernetes_service_annotation_prometheus_io_port\"], \"target_label\": \"__address__\"}, {\"action\": \"labelmap\", \"regex\": \"__meta_kubernetes_service_label_(.+)\"}, {\"action\": \"replace\", \"source_labels\": [\"__meta_kubernetes_namespace\"], \"target_label\": \"kubernetes_namespace\"}, {\"action\": \"replace\", \"source_labels\": [\"__meta_kubernetes_service_name\"], \"target_label\": \"kubernetes_name\"}]}, {\"job_name\": \"kubernetes_services\", \"kubernetes_sd_configs\": [{\"role\": \"service\"}], \"metrics_path\": \"/probe\", \"params\": {\"module\": [\"http_2xx\"]}, \"relabel_configs\": [{\"action\": \"keep\", \"regex\": true, \"source_labels\": [\"__meta_kubernetes_service_annotation_prometheus_io_probe\"]}, {\"action\": \"labelmap\", \"regex\": \"__meta_kubernetes_service_label_(.+)\"}, {\"source_labels\": [\"__meta_kubernetes_service_namespace\"], \"target_label\": \"kubernetes_namespace\"}, {\"source_labels\": [\"__meta_kubernetes_service_name\"], \"target_label\": \"kubernetes_name\"}, {\"action\": \"labelmap\", \"regex\": \"__meta_kubernetes_service_annotation_bitnami_com_(.+)\"}, {\"regex\": \"(.*)\", \"replacement\": \"$1\", \"source_labels\": [\"__meta_kubernetes_service_annotation_bitnami_com_vhost\"], \"target_label\": \"__param_target\"}, {\"replacement\": \"blackbox:9115\", \"target_label\": \"__address__\"}]}, {\"job_name\": \"prometheus\", \"static_configs\": [{\"targets\": [\"localhost:9090\"]}]}]}",
      "sre.rules": "# Constantly restarting containers\nALERT CrashLooping\n  IF sum(rate(kube_pod_container_status_restarts{namespace=~\"kube-system|monitoring|nginx-ingress\"}[15m])) by (namespace,container) * 3600 > 0\n  FOR 1h\n  LABELS { severity = \"notice\" }\n  ANNOTATIONS {\n    summary = \"Frequently restarting containers\",\n    description = \"{{ $labels.namespace }}/{{ $labels.container }} is restarting {{ $value }} times per hour\",\n  }\n\n# NB: Probably won't be able to alert, if the config is sufficiently broken.\nALERT PrometheusBadConfig\n  IF prometheus_config_last_reload_successful{kubernetes_namespace=\"monitoring\"} == 0\n  FOR 10m\n  LABELS { severity = \"critical\" }\n  ANNOTATIONS {\n    summary = \"Prometheus failed to reload config\",\n    description = \"Config error with prometheus, see container logs\",\n  }\n\n# NB: Probably won't be able to alert, if the config is sufficiently broken.\nALERT AlertmanagerBadConfig\n  IF alertmanager_config_last_reload_successful{kubernetes_namespace=\"monitoring\"} == 0\n  FOR 10m\n  LABELS { severity = \"critical\" }\n  ANNOTATIONS {\n    summary = \"Alertmanager failed to reload config\",\n    description = \"Config error with alertmanager, see container logs\",\n  }\n\n# NB: Probably won't be able to alert, if prom/am are hard down.\nALERT MonitoringJobDown\n  IF up{kubernetes_namespace=\"monitoring\", name=\"prometheus\"} != 1 or\n     up{kubernetes_namespace=\"monitoring\", name=\"alertmanager\"} != 1 or\n     up{kubernetes_namespace=\"monitoring\", name=\"blackbox\"} != 1 or\n     up{kubernetes_namespace=\"monitoring\", name=\"grafana\"} != 1 or\n     up{kubernetes_namespace=\"monitoring\", name=\"kube-state-metrics\"} != 1\n  FOR 10m\n  LABELS { severity = \"critical\" }\n  ANNOTATIONS {\n    summary = \"Required monitoring job is not running\",\n    description = \"{{ $labels.kubernetes_namespace }}/{{ $labels.name }} is down\",\n  }\n\n# This \"legitimately\" gets out of sync during a cluster\n# rolling-update, and the impact isn't as great - so use a more\n# forgiving duration.\nALERT MonitoringJobDownNode\n  IF sum(up{kubernetes_namespace=\"monitoring\",name=\"node-exporter\"}) !=\n     sum(kube_node_status_condition{condition=\"Ready\",status=\"true\"})\n  FOR 60m\n  LABELS { severity = \"warning\" }\n  ANNOTATIONS {\n    summary = \"Node-level monitoring job is not running\",\n    description = \"node-exporter is down\",\n  }\n\nALERT UnderservedAZ\n  IF sum(up{job=\"kubernetes_nodes\"}) by (failure_domain_beta_kubernetes_io_zone) < 2\n  FOR 1h\n  #TODO: LABELS { severity = \"notice\" }\n  ANNOTATIONS {\n    summary = \"Not enough nodes in AZ\",\n    description = \"Only {{ $value }} nodes are up in AZ {{ $labels.failure_domain_beta_kubernetes_io_zone }}\",\n  }\n\n# This is alerting on a cause rather than a symptom, so is likely to be\n# noisy.  May want to revisit/remove.\nALERT NodeNotReady\n  IF max(kube_node_status_condition{condition=\"Ready\",status=\"false\"} == 1) by (node)\n  FOR 1d\n  #TODO: LABELS { severity = \"notice\" }\n  ANNOTATIONS {\n    summary = \"Node not ready for a long time\",\n    description = \"{{ $labels.node }} has been unready for more than a day\",\n  }\n\nALERT K8sApiUnavailable\n  IF max(up{job=\"kubernetes_apiservers\"}) != 1\n  FOR 10m\n  #TODO: LABELS { severity = \"critical\" }\n  ANNOTATIONS {\n    summary = \"Kubernetes API is unavailable\",\n    description = \"Kubernetes API is not responding\",\n  }\n\nALERT Ec2RootPartitionFull\n  IF node_filesystem_avail{mountpoint=\"/\", job=\"ec2_servers\"} < 200e+06\n  FOR 5m\n  ANNOTATIONS {\n    summary = \"Root partition full in {{ $labels.Name }}\",\n    description = \"Less than 200MB in / available for server {{ $labels.Name }} \"\n  }\n\nALERT Ec2VarPartitionFull\n  IF node_filesystem_avail{mountpoint=\"/var\", job=\"ec2_servers\"} < 200e+06\n  FOR 5m\n  ANNOTATIONS {\n    summary = \"/var partition full in {{ $labels.Name }}\",\n    description = \"Less than 200MB in /var available for server {{ $labels.Name }} \"\n  }\n\nALERT Ec2TmpPartitionFull\n  IF node_filesystem_avail{mountpoint=\"/tmp\", job=\"ec2_servers\"} < 200e+06\n  FOR 5m\n  ANNOTATIONS {\n    summary = \"/tmp partition full in {{ $labels.Name }}\",\n    description = \"Less than 200MB in /tmp available for server {{ $labels.Name }}\"\n  }\n\nALERT Ec2TankDataPartitionFull\n  IF node_filesystem_avail{mountpoint=\"/tank/data\", job=\"ec2_servers\"} < 1e+09\n  FOR 5m\n  ANNOTATIONS {\n    summary = \"/tank/data partition full in {{ $labels.Name }}\",\n    description = \"Less than 1GB in /tank/data available for server {{ $labels.Name }}\"\n  }\n\nALERT Ec2TankLogPartitionFull\n  IF node_filesystem_avail{mountpoint=\"/tank/log\", job=\"ec2_servers\"} < 500e+06\n  FOR 5m\n  ANNOTATIONS {\n    summary = \"/tank/log partition full in {{ $labels.Name }}\",\n    description = \"Less than 500MB in /tank/log available for server {{ $labels.Name }}\"\n  }\n\nALERT Ec2MemoryAvailable\n  IF node_memory_MemAvailable{job=\"ec2_servers\"} < 500e+06\n  FOR 5m\n  ANNOTATIONS {\n    summary = \"Low Available memory in {{ $labels.Name }}\",\n    description = \"Less than 500MB memory available for the last 5 minutes in server {{ $labels.Name }}\"\n  }\n\nALERT Ec2CPU_Usage\n  IF 100 - (avg by (Name) (irate(node_cpu{job=\"ec2_servers\",mode=\"idle\"}[5m])) * 100) > 85\n  ANNOTATIONS {\n    summary = \"High CPU usage in {{ $labels.Name }}\",\n    description = \"CPU usage higher than 85% for more than 5m {{ $labels.Name }}\"\n  }\n\nALERT Ec2ExporterDown\n  IF up{job=\"ec2_servers\"} != 1\n  FOR 5m\n  ANNOTATIONS {\n    summary = \"EC2 Node exporter down in {{ $labels.Name }}\",\n    description = \"Could not contact /metrics endpoint in server {{ $labels.Name }}\"\n  }\n"
   },
   "kind": "ConfigMap",
   "metadata": {
      "annotations": { },
      "labels": {
         "name": "prometheus"
      },
      "name": "prometheus",
      "namespace": "monitoring"
   }
}
